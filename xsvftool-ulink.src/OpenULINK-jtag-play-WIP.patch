diff --git a/configure.ac b/configure.ac
index 32cffcd..4561bf5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 #                                               -*- Autoconf -*-
 ## Process this file with autoconf to produce a configure script.
 
-AC_PREREQ(2.68)
+AC_PREREQ(2.65)
 AC_INIT(jtagtool, 0.1, martin.schmoelzer@student.tuwien.ac.at)
 AC_CONFIG_MACRO_DIR([m4])
 AC_CONFIG_SRCDIR([src/main.cc])
diff --git a/src/drivers/OpenULINK/Makefile b/src/drivers/OpenULINK/Makefile
index ff2b172..6f14973 100644
--- a/src/drivers/OpenULINK/Makefile
+++ b/src/drivers/OpenULINK/Makefile
@@ -23,15 +23,15 @@
 PREFIX =
 
 # Small Device C Compiler: http://sdcc.sourceforge.net/
-CC = $(PREFIX)-sdcc
+CC = $(PREFIX)sdcc
 
 # 8051 assembler, part of the SDCC software package.
-AS = $(PREFIX)-sdas8051
+AS = $(PREFIX)asx8051
 
 # SDCC produces quite messy Intel HEX files. This tool is be used to re-format
 # those files. It is not required for the firmware download functionality in
 # the OpenOCD driver, but the resulting file is smaller.
-PACKIHX = $(PREFIX)-packihx
+PACKIHX = $(PREFIX)packihx
 
 # GNU binutils size. Used to print the size of the IHX file generated by SDCC.
 SIZE = size
@@ -80,7 +80,8 @@ ulink_firmware.ihx: $(OBJECTS)
 	$(CC) -c $(CFLAGS) -mmcs51 -I$(INCLUDE_DIR) -o $@ $<
 
 %.rel: $(SRC_DIR)/%.a51
-	$(AS) -lsgo $@ $<
+	cp $< $(notdir $<)
+	$(AS) -lsgo $(notdir $<)
 
 clean:
 	rm -f *.asm *.lst *.rel *.rst *.sym *.ihx *.lnk *.map *.mem
diff --git a/src/drivers/OpenULINK/include/jtag.h b/src/drivers/OpenULINK/include/jtag.h
index ca86671..f1d7efb 100644
--- a/src/drivers/OpenULINK/include/jtag.h
+++ b/src/drivers/OpenULINK/include/jtag.h
@@ -34,6 +34,8 @@ void jtag_slow_scan_out(uint8_t out_offset);
 void jtag_scan_io(uint8_t out_offset, uint8_t in_offset);
 void jtag_slow_scan_io(uint8_t out_offset, uint8_t in_offset);
 
+void jtag_play(uint8_t out_offset, uint8_t in_offset);
+
 void jtag_clock_tck(uint16_t count);
 void jtag_slow_clock_tck(uint16_t count);
 void jtag_clock_tms(uint8_t count, uint8_t sequence);
diff --git a/src/drivers/OpenULINK/include/msgtypes.h b/src/drivers/OpenULINK/include/msgtypes.h
index cb35612..de32cfb 100644
--- a/src/drivers/OpenULINK/include/msgtypes.h
+++ b/src/drivers/OpenULINK/include/msgtypes.h
@@ -152,6 +152,7 @@
 #define CMD_SLOW_SCAN_OUT       0x03
 #define CMD_SCAN_IO             0x04
 #define CMD_SLOW_SCAN_IO        0x05
+#define CMD_PLAY                0x06
 
 /* Commands with fixed payload size */
 #define CMD_CLOCK_TMS           0x20
diff --git a/src/drivers/OpenULINK/src/USBJmpTb.a51 b/src/drivers/OpenULINK/src/USBJmpTb.a51
index 6f774dd..03d76d9 100644
--- a/src/drivers/OpenULINK/src/USBJmpTb.a51
+++ b/src/drivers/OpenULINK/src/USBJmpTb.a51
@@ -28,7 +28,7 @@
 .area   USB_JV (ABS,OVR)   ; Absolute, Overlay
 .org    0x43               ; USB interrupt (INT2) jumps here
 USB_AutoVector = #. + 2
-    ljmp  USB_jump_table
+    ljmp  USB_Jump_Table
 
 ;--------------------------------------------------------------------------;
 ; USB Jump Table                                                           ;
@@ -36,7 +36,7 @@ USB_AutoVector = #. + 2
 .area  USB_JT (ABS)        ; Absolute placement
 .org   0x1B00              ; Place jump table at 0x1B00
 
-USB_jump_table:            ; autovector jump table
+USB_Jump_Table:            ; autovector jump table
     ljmp  _sudav_isr       ; Setup Data Available
     .db 0
     ljmp  _sof_isr         ; Start of Frame
diff --git a/src/drivers/OpenULINK/src/jtag.c b/src/drivers/OpenULINK/src/jtag.c
index 3c2fea2..c8350b3 100644
--- a/src/drivers/OpenULINK/src/jtag.c
+++ b/src/drivers/OpenULINK/src/jtag.c
@@ -584,6 +584,288 @@ void jtag_slow_scan_io(uint8_t out_offset, uint8_t in_offset)
 }
 
 /**
+ * Play set of JTAG transactions (one transaction per nibble)
+ *
+ * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TMS,
+ * TCK and TRST. TDO data is sampled and stored in the EP2 IN buffer.
+ *
+ * Maximum achievable TCK frequency is 160 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_play(uint8_t out_offset, uint8_t in_offset)
+{
+	// SDCC passes the first argument in dpl and the second argument in _jtag_play_PARM_2
+	// we simply copy the arguments to r2 and r3 right at the start of our asm block
+	// FIXME: Maybe there is a better and more portable way to access the arguments?
+
+_asm
+	; r2 <- out_offset
+	; r3 <- in_offset
+	mov	r2,	dpl
+	mov	r3,	_jtag_play_PARM_2
+
+	; r4 <- num of blocks to process + in_offset
+	; _OUT2BUF is aligned in a way that we will not
+	; overflow in this simple address calculation
+	mov	a,	#(_OUT2BUF >> 8)
+	mov	dph,	a
+	mov	a,	r2
+	add	a,	#_OUT2BUF
+	mov	dpl,	a
+	movx	a,	@dptr
+	add	a,	r3
+	mov	r4,	a
+	inc	r2
+
+	; r5 <- high nibble of OUTB
+	mov	dptr,	#_OUTB
+	movx	a,	@dptr
+	anl	a,	#0xf0
+	mov	r5,	a
+
+	; main loop begin
+jtag_play_loop_head:
+	clr	c
+	mov	a,	r3
+	subb	a,	r4
+	jc	jtag_play_loop_body
+	ret
+jtag_play_loop_body:
+
+	; initialize result byte
+	mov 	r7,	#0
+
+	; ================== TRANSFER 1/8 ==================
+
+	; load command to r6
+	mov	dph,	#(_OUT2BUF >> 8)
+	mov	a,	r2
+	add	a,	#_OUT2BUF
+	mov	dpl,	a
+	movx	a,	@dptr
+	mov	r6,	a
+	inc	r2
+
+	; falling clk edge
+	anl	a,	#0x0f
+	orl	a,	r5
+	mov	dptr,	#_OUTB
+	movx	@dptr,	a
+
+	; rising clk edge
+	orl	a,	#0x04
+	movx	@dptr,	a
+
+	; checking tdo
+	mov	dptr,	#_PINSA
+	movx	a,	@dptr
+	jnb	acc.5,	jtag_play_tdo_0x01
+	mov	a,	r7
+	orl	a,	#0x01
+	mov	r7,	a
+jtag_play_tdo_0x01:
+
+	; ================== TRANSFER 2/8 ==================
+
+	; falling clk edge
+	mov	a,	r6
+	swap	a
+	anl	a,	#0x0f
+	orl	a,	r5
+	mov	dptr,	#_OUTB
+	movx	@dptr,	a
+
+	; rising clk edge
+	orl	a,	#0x04
+	movx	@dptr,	a
+
+	; checking tdo
+	mov	dptr,	#_PINSA
+	movx	a,	@dptr
+	jnb	acc.5,	jtag_play_tdo_0x02
+	mov	a,	r7
+	orl	a,	#0x02
+	mov	r7,	a
+jtag_play_tdo_0x02:
+
+	; ================== TRANSFER 3/8 ==================
+
+	; load command to r6
+	mov	dph,	#(_OUT2BUF >> 8)
+	mov	a,	r2
+	add	a,	#_OUT2BUF
+	mov	dpl,	a
+	movx	a,	@dptr
+	mov	r6,	a
+	inc	r2
+
+	; falling clk edge
+	anl	a,	#0x0f
+	orl	a,	r5
+	mov	dptr,	#_OUTB
+	movx	@dptr,	a
+
+	; rising clk edge
+	orl	a,	#0x04
+	movx	@dptr,	a
+
+	; checking tdo
+	mov	dptr,	#_PINSA
+	movx	a,	@dptr
+	jnb	acc.5,	jtag_play_tdo_0x04
+	mov	a,	r7
+	orl	a,	#0x04
+	mov	r7,	a
+jtag_play_tdo_0x04:
+
+	; ================== TRANSFER 4/8 ==================
+
+	; falling clk edge
+	mov	a,	r6
+	swap	a
+	anl	a,	#0x0f
+	orl	a,	r5
+	mov	dptr,	#_OUTB
+	movx	@dptr,	a
+
+	; rising clk edge
+	orl	a,	#0x04
+	movx	@dptr,	a
+
+	; checking tdo
+	mov	dptr,	#_PINSA
+	movx	a,	@dptr
+	jnb	acc.5,	jtag_play_tdo_0x08
+	mov	a,	r7
+	orl	a,	#0x08
+	mov	r7,	a
+jtag_play_tdo_0x08:
+
+	; ================== TRANSFER 5/8 ==================
+
+	; load command to r6
+	mov	dph,	#(_OUT2BUF >> 8)
+	mov	a,	r2
+	add	a,	#_OUT2BUF
+	mov	dpl,	a
+	movx	a,	@dptr
+	mov	r6,	a
+	inc	r2
+
+	; falling clk edge
+	anl	a,	#0x0f
+	orl	a,	r5
+	mov	dptr,	#_OUTB
+	movx	@dptr,	a
+
+	; rising clk edge
+	orl	a,	#0x04
+	movx	@dptr,	a
+
+	; checking tdo
+	mov	dptr,	#_PINSA
+	movx	a,	@dptr
+	jnb	acc.5,	jtag_play_tdo_0x10
+	mov	a,	r7
+	orl	a,	#0x10
+	mov	r7,	a
+jtag_play_tdo_0x10:
+
+	; ================== TRANSFER 6/8 ==================
+
+	; falling clk edge
+	mov	a,	r6
+	swap	a
+	anl	a,	#0x0f
+	orl	a,	r5
+	mov	dptr,	#_OUTB
+	movx	@dptr,	a
+
+	; rising clk edge
+	orl	a,	#0x04
+	movx	@dptr,	a
+
+	; checking tdo
+	mov	dptr,	#_PINSA
+	movx	a,	@dptr
+	jnb	acc.5,	jtag_play_tdo_0x20
+	mov	a,	r7
+	orl	a,	#0x20
+	mov	r7,	a
+jtag_play_tdo_0x20:
+
+	; ================== TRANSFER 7/8 ==================
+
+	; load command to r6
+	mov	dph,	#(_OUT2BUF >> 8)
+	mov	a,	r2
+	add	a,	#_OUT2BUF
+	mov	dpl,	a
+	movx	a,	@dptr
+	mov	r6,	a
+	inc	r2
+
+	; falling clk edge
+	anl	a,	#0x0f
+	orl	a,	r5
+	mov	dptr,	#_OUTB
+	movx	@dptr,	a
+
+	; rising clk edge
+	orl	a,	#0x04
+	movx	@dptr,	a
+
+	; checking tdo
+	mov	dptr,	#_PINSA
+	movx	a,	@dptr
+	jnb	acc.5,	jtag_play_tdo_0x40
+	mov	a,	r7
+	orl	a,	#0x40
+	mov	r7,	a
+jtag_play_tdo_0x40:
+
+	; ================== TRANSFER 8/8 ==================
+
+	; falling clk edge
+	mov	a,	r6
+	swap	a
+	anl	a,	#0x0f
+	orl	a,	r5
+	mov	dptr,	#_OUTB
+	movx	@dptr,	a
+
+	; rising clk edge
+	orl	a,	#0x04
+	movx	@dptr,	a
+
+	; checking tdo
+	mov	dptr,	#_PINSA
+	movx	a,	@dptr
+	jnb	acc.5,	jtag_play_tdo_0x80
+	mov	a,	r7
+	orl	a,	#0x80
+	mov	r7,	a
+jtag_play_tdo_0x80:
+
+	; ================== END TRANSFER ==================
+
+	; store result byte
+	mov	a,	#(_IN2BUF >> 8)
+	mov	dph,	a
+	mov	a,	r3
+	add	a,	#_IN2BUF
+	mov	dpl,	a
+	mov	a,	r7
+	movx	@dptr,	a
+	inc	r3
+
+	; main loop end
+	ljmp	jtag_play_loop_head
+_endasm;
+}
+
+/**
  * Generate TCK clock cycles.
  *
  * Maximum achievable TCK frequency is 375 kHz for ULINK clocked at 24 MHz.
diff --git a/src/drivers/OpenULINK/src/protocol.c b/src/drivers/OpenULINK/src/protocol.c
index ae63604..575e7ce 100644
--- a/src/drivers/OpenULINK/src/protocol.c
+++ b/src/drivers/OpenULINK/src/protocol.c
@@ -135,6 +135,11 @@ bool execute_command(void)
     usb_out_bytecount = usb_in_bytecount + 5;
     jtag_slow_scan_io(cmd_id_index + 1, payload_index_in);
     break;
+  case CMD_PLAY:
+    usb_in_bytecount = OUT2BUF[cmd_id_index + 1];
+    usb_out_bytecount = usb_in_bytecount << 2 + 2;
+    jtag_play(cmd_id_index + 1, payload_index_in);
+    break;
   case CMD_SLOW_CLOCK_TMS:
     usb_out_bytecount = 2;
     jtag_slow_clock_tms(OUT2BUF[cmd_id_index + 1], OUT2BUF[cmd_id_index + 2]);
@@ -218,8 +223,10 @@ void command_loop(void)
     payload_index_in = 0;
 
     /* Wait until host sends EP2 Bulk-OUT packet */
-    while (!EP2_out);
-    EP2_out = 0;
+    while (OUT2CS);
+
+    /* Wait until host clears EP2 Bulk-IN packet */
+    while (IN2CS);
 
     /* Turn on COM LED to indicate command execution */
     SET_COM_LED();
@@ -231,14 +238,11 @@ void command_loop(void)
     }
 
     CLEAR_COM_LED();
-    
+
     /* Send back EP2 Bulk-IN packet if required */
-    if (payload_index_in > 0) {
+    if (payload_index_in > 0)
       IN2BC = payload_index_in;
-      while (!EP2_in);
-      EP2_in = 0;
-    }
-
+    
     /* Re-arm EP2-OUT after command execution */
     OUT2BC = 0;
   }
diff --git a/src/drivers/OpenULINK/src/usb.c b/src/drivers/OpenULINK/src/usb.c
index 7a84d2a..bd14c59 100644
--- a/src/drivers/OpenULINK/src/usb.c
+++ b/src/drivers/OpenULINK/src/usb.c
@@ -165,27 +165,8 @@ void ep0in_isr(void)    __interrupt EP0IN_ISR    { }
 void ep0out_isr(void)   __interrupt EP0OUT_ISR   { }
 void ep1in_isr(void)    __interrupt EP1IN_ISR    { }
 void ep1out_isr(void)   __interrupt EP1OUT_ISR   { }
-
-/**
- * EP2 IN: called after the transfer from uC->Host has finished: we sent data
- */
-void ep2in_isr(void)    __interrupt EP2IN_ISR { 
-  EP2_in = 1;
-
-  CLEAR_IRQ();
-  IN07IRQ = IN2IR;     // Clear OUT2 IRQ
-}
-
-/**
- * EP2 OUT: called after the transfer from Host->uC has finished: we got data
- */
-void ep2out_isr(void)   __interrupt EP2OUT_ISR {
-  EP2_out = 1;
-
-  CLEAR_IRQ();
-  OUT07IRQ = OUT2IR;    // Clear OUT2 IRQ
-}
-
+void ep2in_isr(void)    __interrupt EP2IN_ISR    { }
+void ep2out_isr(void)   __interrupt EP2OUT_ISR   { }
 void ep3in_isr(void)    __interrupt EP3IN_ISR    { }
 void ep3out_isr(void)   __interrupt EP3OUT_ISR   { }
 void ep4in_isr(void)    __interrupt EP4IN_ISR    { }
@@ -537,9 +518,9 @@ void usb_init(void) {
   /* Enable SUDAV interrupt */
   USBIEN |= SUDAVIE;
 
-  /* Enable EP2 OUT & IN interrupts */
-  OUT07IEN = OUT2IEN;
-  IN07IEN  = IN2IEN;
+  /* Enable endpoint pairing */
+  USBPAIR |= PR2OUT;
+  USBPAIR |= PR2IN;
 
   /* Enable USB interrupt (EIE register) */
   EUSB = 1;
